"""
Provider for pre-computed time-varying uncertainty sets.

This module provides an API for loading and querying pre-computed uncertainty
sets (mu, Sigma, rho) generated by the uncertainty calibration pipeline.

Usage:
    >>> from uncertainty_set_provider import UncertaintySetProvider
    >>> provider = UncertaintySetProvider.from_npz("data/uncertainty_sets/sigma_rho.npz")
    >>> provider.n_available
    2160
    >>> horizon = provider.get_by_indices(start_idx=0, n_hours=48)
    >>> horizon.sigma.shape
    (48, 4, 4)
"""

from __future__ import annotations

import json
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional

import numpy as np


def _safe_cholesky(
    sigma: np.ndarray,
    max_tries: int = 8,
    initial_ridge: float = 1e-6,
    ridge_mult: float = 10.0,
) -> np.ndarray:
    """
    Compute Cholesky decomposition with automatic ridge regularization.

    If the initial Cholesky fails, progressively larger ridge values are
    tried until the decomposition succeeds.

    Parameters
    ----------
    sigma : np.ndarray
        Symmetric positive semi-definite matrix, shape (K, K)
    max_tries : int
        Maximum number of attempts with increasing ridge
    initial_ridge : float
        Starting ridge value
    ridge_mult : float
        Multiplier for ridge at each attempt

    Returns
    -------
    np.ndarray
        Lower Cholesky factor L such that L @ L.T â‰ˆ sigma
    """
    ridge = initial_ridge
    I = np.eye(sigma.shape[0])

    for attempt in range(max_tries):
        try:
            if attempt == 0:
                return np.linalg.cholesky(sigma)
            else:
                return np.linalg.cholesky(sigma + ridge * I)
        except np.linalg.LinAlgError:
            ridge *= ridge_mult

    # Final attempt with large ridge
    return np.linalg.cholesky(sigma + ridge * I)


@dataclass
class HorizonUncertaintySet:
    """
    Uncertainty parameters for a multi-hour horizon.

    Attributes
    ----------
    indices : List[int]
        Sequential indices used (relative to the full uncertainty set)
    sigma : np.ndarray
        Covariance matrices, shape (T, K, K) where T=n_periods, K=n_wind
    rho : np.ndarray
        Ellipsoid radii, shape (T,)
    mu : np.ndarray
        Mean vectors, shape (T, K)
    sqrt_sigma : np.ndarray or None
        Cholesky factors of sigma, shape (T, K, K)
        Only computed if compute_sqrt=True in get_by_indices

    Notes
    -----
    The ellipsoidal uncertainty set at time t is:
        {r : (r - mu[t])^T Sigma[t]^{-1} (r - mu[t]) <= rho[t]^2}

    Or equivalently using the Cholesky factor L = sqrt_sigma[t]:
        {mu[t] + L @ z : ||z||_2 <= rho[t]}
    """

    indices: List[int]
    sigma: np.ndarray
    rho: np.ndarray
    mu: np.ndarray
    sqrt_sigma: Optional[np.ndarray] = None

    @property
    def n_periods(self) -> int:
        """Number of time periods in this horizon."""
        return len(self.indices)

    @property
    def n_wind(self) -> int:
        """Number of wind resources."""
        return self.sigma.shape[1]

    def get_single(self, t: int) -> "SinglePeriodUncertaintySet":
        """
        Get uncertainty set for a single period within this horizon.

        Parameters
        ----------
        t : int
            Period index within this horizon (0-indexed)

        Returns
        -------
        SinglePeriodUncertaintySet
            Uncertainty set for period t
        """
        if t < 0 or t >= self.n_periods:
            raise IndexError(f"Period {t} out of range [0, {self.n_periods})")

        return SinglePeriodUncertaintySet(
            index=self.indices[t],
            sigma=self.sigma[t],
            rho=self.rho[t],
            mu=self.mu[t],
            sqrt_sigma=self.sqrt_sigma[t] if self.sqrt_sigma is not None else None,
        )


@dataclass
class SinglePeriodUncertaintySet:
    """
    Uncertainty parameters for a single time period.

    Attributes
    ----------
    index : int
        Sequential index in the full uncertainty set
    sigma : np.ndarray
        Covariance matrix, shape (K, K)
    rho : float
        Ellipsoid radius
    mu : np.ndarray
        Mean vector, shape (K,)
    sqrt_sigma : np.ndarray or None
        Cholesky factor of sigma, shape (K, K)
    """

    index: int
    sigma: np.ndarray
    rho: float
    mu: np.ndarray
    sqrt_sigma: Optional[np.ndarray] = None

    @property
    def n_wind(self) -> int:
        """Number of wind resources."""
        return len(self.mu)


class UncertaintySetProvider:
    """
    Provider for pre-computed time-varying uncertainty sets.

    Uses sequential index matching (not timestamp-based) since RTS and wind
    data may have different time origins. The provider exposes all uncertainty
    sets in order of their generation.

    Attributes
    ----------
    n_available : int
        Total hours of uncertainty data available
    n_wind : int
        Number of wind resources

    Methods
    -------
    from_npz(npz_path)
        Load provider from NPZ file
    get_by_indices(start_idx, n_hours)
        Get uncertainty sets for a contiguous range of hours
    get_wind_gen_ids()
        Return wind generator IDs

    Example
    -------
    >>> provider = UncertaintySetProvider.from_npz("data/uncertainty_sets/sigma_rho.npz")
    >>> print(f"Available: {provider.n_available} hours, {provider.n_wind} wind units")
    >>> horizon = provider.get_by_indices(start_idx=0, n_hours=48)
    >>> print(f"Sigma shape: {horizon.sigma.shape}")
    >>> print(f"rho range: [{horizon.rho.min():.3f}, {horizon.rho.max():.3f}]")
    """

    def __init__(
        self,
        mu: np.ndarray,
        sigma: np.ndarray,
        rho: np.ndarray,
        omega: np.ndarray,
        y_cols: List[str],
        times: Optional[np.ndarray] = None,
        x_cols: Optional[List[str]] = None,
        metadata: Optional[dict] = None,
    ):
        """
        Initialize provider with pre-computed arrays.

        Parameters
        ----------
        mu : np.ndarray
            Mean vectors, shape (N, K)
        sigma : np.ndarray
            Covariance matrices, shape (N, K, K)
        rho : np.ndarray
            Ellipsoid radii, shape (N,)
        omega : np.ndarray
            Learned feature weights, shape (D,)
        y_cols : List[str]
            Wind resource/generator IDs
        times : np.ndarray, optional
            Timestamps for each hour, shape (N,)
        x_cols : List[str], optional
            Feature column names
        metadata : dict, optional
            Additional metadata from generation
        """
        self._mu = np.asarray(mu)
        self._sigma = np.asarray(sigma)
        self._rho = np.asarray(rho)
        self._omega = np.asarray(omega)
        self._y_cols = list(y_cols)
        self._times = times
        self._x_cols = list(x_cols) if x_cols is not None else None
        self._metadata = metadata or {}

        # Validation
        n = len(self._rho)
        if self._mu.shape[0] != n:
            raise ValueError(f"mu has {self._mu.shape[0]} rows but rho has {n}")
        if self._sigma.shape[0] != n:
            raise ValueError(f"sigma has {self._sigma.shape[0]} rows but rho has {n}")
        if self._mu.shape[1] != len(self._y_cols):
            raise ValueError(
                f"mu has {self._mu.shape[1]} columns but y_cols has {len(self._y_cols)}"
            )

    @classmethod
    def from_npz(cls, npz_path: Path | str) -> "UncertaintySetProvider":
        """
        Load provider from NPZ file.

        Parameters
        ----------
        npz_path : Path or str
            Path to NPZ file generated by generate_uncertainty_sets.py

        Returns
        -------
        UncertaintySetProvider
            Loaded provider
        """
        npz_path = Path(npz_path)
        data = np.load(npz_path, allow_pickle=True)

        # Load optional metadata
        metadata = {}
        metadata_path = npz_path.parent / "metadata.json"
        if metadata_path.exists():
            with open(metadata_path) as f:
                metadata = json.load(f)

        # Load optional arrays
        times = data.get("times", None)
        x_cols = data.get("x_cols", None)
        if x_cols is not None:
            x_cols = list(x_cols)

        return cls(
            mu=data["mu"],
            sigma=data["sigma"],
            rho=data["rho"],
            omega=data["omega"],
            y_cols=list(data["y_cols"]),
            times=times,
            x_cols=x_cols,
            metadata=metadata,
        )

    @property
    def n_available(self) -> int:
        """Total hours of uncertainty data available."""
        return len(self._rho)

    @property
    def n_wind(self) -> int:
        """Number of wind resources."""
        return self._sigma.shape[1]

    @property
    def omega(self) -> np.ndarray:
        """Learned feature weights (read-only copy)."""
        return self._omega.copy()

    @property
    def metadata(self) -> dict:
        """Metadata from generation (read-only copy)."""
        return self._metadata.copy()

    def get_wind_gen_ids(self) -> List[str]:
        """Return wind generator IDs."""
        return self._y_cols.copy()

    def get_feature_cols(self) -> Optional[List[str]]:
        """Return feature column names, if available."""
        return self._x_cols.copy() if self._x_cols is not None else None

    def get_by_indices(
        self,
        start_idx: int,
        n_hours: int,
        compute_sqrt: bool = True,
    ) -> HorizonUncertaintySet:
        """
        Get uncertainty sets for n_hours starting at start_idx.

        Uses sequential indexing (not timestamps). This is appropriate when
        the caller aligns by index rather than by absolute time.

        Parameters
        ----------
        start_idx : int
            Starting index (0-indexed)
        n_hours : int
            Number of hours to retrieve
        compute_sqrt : bool, default=True
            If True, compute Cholesky factors for each Sigma

        Returns
        -------
        HorizonUncertaintySet
            Uncertainty parameters for the requested horizon

        Raises
        ------
        IndexError
            If requested range exceeds available data
        """
        end_idx = start_idx + n_hours
        if start_idx < 0:
            raise IndexError(f"start_idx must be non-negative, got {start_idx}")
        if end_idx > self.n_available:
            raise IndexError(
                f"Requested indices [{start_idx}, {end_idx}) but only "
                f"{self.n_available} hours available"
            )

        indices = list(range(start_idx, end_idx))
        sigma = self._sigma[start_idx:end_idx].copy()
        rho = self._rho[start_idx:end_idx].copy()
        mu = self._mu[start_idx:end_idx].copy()

        sqrt_sigma = None
        if compute_sqrt:
            sqrt_sigma = np.zeros_like(sigma)
            for t in range(n_hours):
                sqrt_sigma[t] = _safe_cholesky(sigma[t])

        return HorizonUncertaintySet(
            indices=indices,
            sigma=sigma,
            rho=rho,
            mu=mu,
            sqrt_sigma=sqrt_sigma,
        )

    def get_single(
        self,
        idx: int,
        compute_sqrt: bool = True,
    ) -> SinglePeriodUncertaintySet:
        """
        Get uncertainty set for a single period.

        Parameters
        ----------
        idx : int
            Index (0-indexed)
        compute_sqrt : bool, default=True
            If True, compute Cholesky factor for Sigma

        Returns
        -------
        SinglePeriodUncertaintySet
            Uncertainty parameters for the requested period
        """
        if idx < 0 or idx >= self.n_available:
            raise IndexError(f"Index {idx} out of range [0, {self.n_available})")

        sigma = self._sigma[idx].copy()
        sqrt_sigma = None
        if compute_sqrt:
            sqrt_sigma = _safe_cholesky(sigma)

        return SinglePeriodUncertaintySet(
            index=idx,
            sigma=sigma,
            rho=float(self._rho[idx]),
            mu=self._mu[idx].copy(),
            sqrt_sigma=sqrt_sigma,
        )

    def get_rho_statistics(self) -> dict:
        """
        Get summary statistics for rho values.

        Returns
        -------
        dict
            Statistics including min, max, mean, std, median
        """
        return {
            "min": float(self._rho.min()),
            "max": float(self._rho.max()),
            "mean": float(self._rho.mean()),
            "std": float(self._rho.std()),
            "median": float(np.median(self._rho)),
            "q25": float(np.percentile(self._rho, 25)),
            "q75": float(np.percentile(self._rho, 75)),
        }

    def __repr__(self) -> str:
        return (
            f"UncertaintySetProvider("
            f"n_available={self.n_available}, "
            f"n_wind={self.n_wind}, "
            f"wind_ids={self._y_cols})"
        )


# Smoke test
if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1:
        npz_path = Path(sys.argv[1])
    else:
        # Default path for testing (RTS4 data)
        npz_path = Path(__file__).parent / "uncertainty_sets_refactored" / "data" / "uncertainty_sets_rts4" / "sigma_rho.npz"

    if not npz_path.exists():
        print(f"NPZ file not found at {npz_path}")
        print("Run generate_uncertainty_sets.py first to create the file.")
        sys.exit(1)

    print(f"Loading from {npz_path}")
    provider = UncertaintySetProvider.from_npz(npz_path)

    print(f"\n{provider}")
    print(f"Wind generator IDs: {provider.get_wind_gen_ids()}")
    print(f"\nrho statistics:")
    for key, val in provider.get_rho_statistics().items():
        print(f"  {key}: {val:.4f}")

    # Test getting a horizon
    print("\nTesting get_by_indices(0, 48):")
    horizon = provider.get_by_indices(0, 48)
    print(f"  indices: {horizon.indices[:5]}...{horizon.indices[-5:]}")
    print(f"  sigma shape: {horizon.sigma.shape}")
    print(f"  rho range: [{horizon.rho.min():.3f}, {horizon.rho.max():.3f}]")
    print(f"  mu shape: {horizon.mu.shape}")
    print(f"  sqrt_sigma shape: {horizon.sqrt_sigma.shape}")

    # Test single period access
    print("\nTesting get_single(0):")
    single = provider.get_single(0)
    print(f"  index: {single.index}")
    print(f"  sigma shape: {single.sigma.shape}")
    print(f"  rho: {single.rho:.4f}")
    print(f"  mu: {single.mu}")

    print("\nSmoke test passed!")
